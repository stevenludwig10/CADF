{
    "type": [
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        3,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        3,
        0,
        1,
        3,
        0,
        1,
        2,
        2,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        3,
        0,
        1,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        3,
        0,
        1,
        3,
        2,
        0,
        1,
        3,
        3,
        3,
        0,
        1,
        2,
        0,
        1,
        3,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        3,
        0,
        1,
        2,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        3,
        0,
        1,
        3,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        3,
        2,
        0,
        1,
        0,
        1,
        3,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        3,
        0,
        1,
        2,
        2,
        2,
        0,
        1,
        2
    ],
    "data": [
        "+ ",
        "            self$purchase_string <-",
        "+ ",
        "                create.purchase.string(df_customer, names(df_customer[1]), names(df_customer[2]))",
        "+ ",
        "            self$purchase_stringM <-",
        "+ ",
        "                create.purchase.string(df_customer, names(df_customer[1]), names(df_customer[2]), mode = \"matridf_customer\")",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$purchase_stringF <- frequency_by_T(df_customer)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$T <- ps_to_T(self$purchase_string)",
        "+ ",
        "            self$Freq <- sum(self$purchase_stringM)",
        "+ ",
        "            self$transaction_range_complete <- nchar(self$purchase_string)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$logistic_modeling_matridf_customer <-",
        "+ ",
        "                f_CustomerModelingMatridf_customer(self$T)",
        "+ ",
        "            self$transaction_string <-",
        "+ ",
        "                paste(",
        "+ ",
        "                    ifelse(self$logistic_modeling_matridf_customer[, 2] == 0, \"Y\", \"N\"),",
        "+ ",
        "                    sep = \"\",",
        "+ ",
        "                    collapse = \"\"",
        "+ ",
        "                )",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #analysis by day",
        "+ ",
        "            self$daily$purchase_count <- length(self$transaction_dates)",
        "+ ",
        "            self$daily$frequency <- length(unique(self$transaction_dates))",
        "+ ",
        "            ",
        "+ ",
        "            #analysis by week",
        "+ ",
        "            self$weekly$Frequency <- length(unique(df_customer$yr_week))",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$output <- list(c(self$global, self$monthly))",
        "+ ",
        "            self$payload <- jsonlite::toJSON(self$output)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "        }",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "    )",
        "+ ",
        ")",
        "> ",
        "test <- Customer2$new(df_customer = x)",
        "Error in initialize(...) : \n  unused argument (df_customer = list(c(2, 2), c(9873, 9873), c(1, 5), c(12, 77)))\n",
        "> ",
        "test <- Customer2$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "",
        "> ",
        "",
        "> ",
        "#' R6 Class representing a customer.  Otherwise known as the CADF.",
        "> ",
        "#'",
        "> ",
        "#' Call Customer$new() to convert transactional data to CADF format",
        "> ",
        "# Common ways that this class is used.",
        "> ",
        "# 1.) Load transactional data.  Make sure to format dates and only pull ID and prchase date",
        "> ",
        "# If you are testing send a single customerid and data for a single customer to id_to_CADF.",
        "> ",
        "# If your data contains multiple customer id's",
        "> ",
        "# 2.) Split the data from 2 using the R split function",
        "> ",
        "# 3.) Call -> split.transaction.file_to_CADF",
        "> ",
        "",
        "> ",
        "#' @edf_customerport Customer",
        "> ",
        "#' @param ... All arguements in list",
        "> ",
        "#' ",
        "> ",
        "#' data(transactions)",
        "> ",
        "#' a <- split(transactions, transactions$ID)",
        "> ",
        "#' cust <- split.transaction.file_to_CADF(a)",
        "> ",
        "#' cust[[1]]",
        "> ",
        "#' ",
        "> ",
        "",
        "> ",
        "Customer2 <- R6::R6Class(",
        "+ ",
        "    \"Customer\",",
        "+ ",
        "    public = list(",
        "+ ",
        "        #' @field output Stores all information in R format at the customer level.",
        "+ ",
        "        output = NULL ,",
        "+ ",
        "        ",
        "+ ",
        "        #'@field payload Stores all computed customer information in JSON format.  This is not quite an API but designed so that customer information can be imported to other formats and systems.",
        "+ ",
        "        payload = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #'@field df_customer a data frame that stores purchase information for a single customer",
        "+ ",
        "        df_customer = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field id The customer id.  This will be the same ID as provided in the input transaction file.",
        "+ ",
        "        id = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field study_name.  A name to associate with the cohort study.#The name can be whatever is easiest to associate with the set of customer id and dates included in",
        "+ ",
        "        #' the analysis.",
        "+ ",
        "        study_name = \"Customer Study\",",
        "+ ",
        "        ",
        "+ ",
        "        #' @field study_begin_date  Begin date of the customer study.  In theory this should be min(TRANSACTION_DATE) for each customer in the dataset.",
        "+ ",
        "        study_begin_date = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field timing.",
        "+ ",
        "        #' Monthly timing computes T as months. Most commonly utilized and is the default.",
        "+ ",
        "        timing = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field transaction_dates.  Description goes here",
        "+ ",
        "        transaction_dates = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field first_purchase_date.  First purchase date for the customer.",
        "+ ",
        "        first_purchase_date = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #'@field last_purchase_date.  Last purchaes date for the customer.",
        "+ ",
        "        last_purchase_date = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' #' @field repeat_customer.  Marked yes if the following conditions",
        "+ ",
        "        #' are true.  The customer has more than one transaction.  The second transaction",
        "+ ",
        "        #' date is greater than the first transaction date.",
        "+ ",
        "        repeat_customer = NULL ,",
        "+ ",
        "        ",
        "+ ",
        "        #'  #' @field  T a measure of time between first date of activity and purchase.",
        "+ ",
        "        T  = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field transaction_range_complete  shows a consecutive sequence usually beginning at 1 to madf_customerimum T",
        "+ ",
        "        transaction_range_complete = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @field logistic_modeling_matridf_customer  customer-level data for logistic modeling.  Each row represents T and 0 is no purchase and 1 is purchase",
        "+ ",
        "        logistic_modeling_matridf_customer = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @field purchase_count purchase count",
        "+ ",
        "        purchase_count = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @field data  Holds data at the customer level",
        "+ ",
        "        data = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @description",
        "+ ",
        "        #' Creates a CADF profile for a given customer",
        "+ ",
        "        #' based on the input transactional data",
        "+ ",
        "        ",
        "+ ",
        "        #' @return A new `Customer` object.  Converted transactional data to CADF format.",
        "+ ",
        "        #' To access cadf[[1]], etc...",
        "+ ",
        "        #' Represents customer data (for a particular id) in the \"CADF\" format",
        "+ ",
        "        initialize = function(x) {",
        "+ ",
        "            stopifnot(CADF::qc_transactional_data(df_customer) == 2)",
        "+ ",
        "            ",
        "+ ",
        "            browser()",
        "+ ",
        "            ",
        "+ ",
        "            self$df_customer <- x",
        "+ ",
        "            ",
        "+ ",
        "            #' @field Tdays to compute \"days from first purchase\"",
        "+ ",
        "            df_customer$Tdays <- ceiling(as.numeric(df_customer[[2]] - min(df_customer[[2]])))",
        "+ ",
        "            ",
        "+ ",
        "            #to compute \"months from first purchase\"",
        "+ ",
        "            df_customer$month_yr <- format(as.Date(df_customer[[2]]), \"%Y-%m\")",
        "+ ",
        "            df_customer$Tmonths <- ceiling(as.numeric(df_customer[[2]] - min(df_customer[[2]])) / 30)",
        "+ ",
        "            ",
        "+ ",
        "            #to compute \"weeks from first purchase",
        "+ ",
        "            df_customer$yr_week = paste(format(as.Date(df_customer[[2]]), \"%Y\") , \"_\" , format(as.Date(df_customer[[2]]), \"%V\"), sep =",
        "+ ",
        "                                            \"\")",
        "+ ",
        "            df_customer$Tweeks <- as.numeric(df_customer[[2]] - min(df_customer[[2]])) / 7",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #sort for output",
        "+ ",
        "            df_customer <- df_customer[order(df_customer[[2]]), ]",
        "+ ",
        "            self$data = df_customer",
        "+ ",
        "            ",
        "+ ",
        "            self$id = min(df_customer[, 1])",
        "+ ",
        "            ",
        "+ ",
        "            browser()",
        "+ ",
        "            self$transaction_dates <- unique(df_customer[, 2])",
        "+ ",
        "            self$transaction_months <- unique(df_customer$month_yr)",
        "+ ",
        "            ",
        "+ ",
        "            self$first_purchase_date <- min(df_customer[, 2])",
        "+ ",
        "            self$last_purchase_date <- madf_customer(df_customer[, 2])",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$repeat_customer <-",
        "+ ",
        "                ifelse(length(unique(self$transaction_months)) > 1, \"Y\", \"N\")",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #construct the purchase string",
        "+ ",
        "            self$purchase_string <- NULL",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$transaction_dates = format(self$transaction_dates, \"%Y_%m\")",
        "+ ",
        "            self$purchase_count = length(unique(self$transaction_dates))  #monthly count",
        "+ ",
        "            ",
        "+ ",
        "            self$purchase_string <-",
        "+ ",
        "                create.purchase.string(df_customer, names(df_customer[1]), names(df_customer[2]))",
        "+ ",
        "            self$purchase_stringM <-",
        "+ ",
        "                create.purchase.string(df_customer, names(df_customer[1]), names(df_customer[2]), mode = \"matridf_customer\")",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$purchase_stringF <- frequency_by_T(df_customer)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$T <- ps_to_T(self$purchase_string)",
        "+ ",
        "            self$Freq <- sum(self$purchase_stringM)",
        "+ ",
        "            self$transaction_range_complete <- nchar(self$purchase_string)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$logistic_modeling_matridf_customer <-",
        "+ ",
        "                f_CustomerModelingMatridf_customer(self$T)",
        "+ ",
        "            self$transaction_string <-",
        "+ ",
        "                paste(",
        "+ ",
        "                    ifelse(self$logistic_modeling_matridf_customer[, 2] == 0, \"Y\", \"N\"),",
        "+ ",
        "                    sep = \"\",",
        "+ ",
        "                    collapse = \"\"",
        "+ ",
        "                )",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #analysis by day",
        "+ ",
        "            self$daily$purchase_count <- length(self$transaction_dates)",
        "+ ",
        "            self$daily$frequency <- length(unique(self$transaction_dates))",
        "+ ",
        "            ",
        "+ ",
        "            #analysis by week",
        "+ ",
        "            self$weekly$Frequency <- length(unique(df_customer$yr_week))",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$output <- list(c(self$global, self$monthly))",
        "+ ",
        "            self$payload <- jsonlite::toJSON(self$output)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "        }",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "    )",
        "+ ",
        ")",
        "> ",
        "test <- Customer2$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "",
        "> ",
        "",
        "> ",
        "#' R6 Class representing a customer.  Otherwise known as the CADF.",
        "> ",
        "#'",
        "> ",
        "#' Call Customer$new() to convert transactional data to CADF format",
        "> ",
        "# Common ways that this class is used.",
        "> ",
        "# 1.) Load transactional data.  Make sure to format dates and only pull ID and prchase date",
        "> ",
        "# If you are testing send a single customerid and data for a single customer to id_to_CADF.",
        "> ",
        "# If your data contains multiple customer id's",
        "> ",
        "# 2.) Split the data from 2 using the R split function",
        "> ",
        "# 3.) Call -> split.transaction.file_to_CADF",
        "> ",
        "",
        "> ",
        "#' @edf_customerport Customer",
        "> ",
        "#' @param ... All arguements in list",
        "> ",
        "#' ",
        "> ",
        "#' data(transactions)",
        "> ",
        "#' a <- split(transactions, transactions$ID)",
        "> ",
        "#' cust <- split.transaction.file_to_CADF(a)",
        "> ",
        "#' cust[[1]]",
        "> ",
        "#' ",
        "> ",
        "",
        "> ",
        "Customer2 <- R6::R6Class(",
        "+ ",
        "    \"Customer\",",
        "+ ",
        "    public = list(",
        "+ ",
        "        #' @field output Stores all information in R format at the customer level.",
        "+ ",
        "        output = NULL ,",
        "+ ",
        "        ",
        "+ ",
        "        #'@field payload Stores all computed customer information in JSON format.  This is not quite an API but designed so that customer information can be imported to other formats and systems.",
        "+ ",
        "        payload = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #'@field df_customer a data frame that stores purchase information for a single customer",
        "+ ",
        "        df_customer = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field id The customer id.  This will be the same ID as provided in the input transaction file.",
        "+ ",
        "        id = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field study_name.  A name to associate with the cohort study.#The name can be whatever is easiest to associate with the set of customer id and dates included in",
        "+ ",
        "        #' the analysis.",
        "+ ",
        "        study_name = \"Customer Study\",",
        "+ ",
        "        ",
        "+ ",
        "        #' @field study_begin_date  Begin date of the customer study.  In theory this should be min(TRANSACTION_DATE) for each customer in the dataset.",
        "+ ",
        "        study_begin_date = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field timing.",
        "+ ",
        "        #' Monthly timing computes T as months. Most commonly utilized and is the default.",
        "+ ",
        "        timing = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field transaction_dates.  Description goes here",
        "+ ",
        "        transaction_dates = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field first_purchase_date.  First purchase date for the customer.",
        "+ ",
        "        first_purchase_date = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #'@field last_purchase_date.  Last purchaes date for the customer.",
        "+ ",
        "        last_purchase_date = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' #' @field repeat_customer.  Marked yes if the following conditions",
        "+ ",
        "        #' are true.  The customer has more than one transaction.  The second transaction",
        "+ ",
        "        #' date is greater than the first transaction date.",
        "+ ",
        "        repeat_customer = NULL ,",
        "+ ",
        "        ",
        "+ ",
        "        #'  #' @field  T a measure of time between first date of activity and purchase.",
        "+ ",
        "        T  = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        #' @field transaction_range_complete  shows a consecutive sequence usually beginning at 1 to madf_customerimum T",
        "+ ",
        "        transaction_range_complete = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @field logistic_modeling_matridf_customer  customer-level data for logistic modeling.  Each row represents T and 0 is no purchase and 1 is purchase",
        "+ ",
        "        logistic_modeling_matridf_customer = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @field purchase_count purchase count",
        "+ ",
        "        purchase_count = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @field data  Holds data at the customer level",
        "+ ",
        "        data = NULL,",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "        #' @description",
        "+ ",
        "        #' Creates a CADF profile for a given customer",
        "+ ",
        "        #' based on the input transactional data",
        "+ ",
        "        ",
        "+ ",
        "        #' @return A new `Customer` object.  Converted transactional data to CADF format.",
        "+ ",
        "        #' To access cadf[[1]], etc...",
        "+ ",
        "        #' Represents customer data (for a particular id) in the \"CADF\" format",
        "+ ",
        "        initialize = function(x) {",
        "+ ",
        "            ",
        "+ ",
        "            browser()",
        "+ ",
        "            ",
        "+ ",
        "            stopifnot(CADF::qc_transactional_data(df_customer) == 2)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$df_customer <- x",
        "+ ",
        "            ",
        "+ ",
        "            #' @field Tdays to compute \"days from first purchase\"",
        "+ ",
        "            df_customer$Tdays <- ceiling(as.numeric(df_customer[[2]] - min(df_customer[[2]])))",
        "+ ",
        "            ",
        "+ ",
        "            #to compute \"months from first purchase\"",
        "+ ",
        "            df_customer$month_yr <- format(as.Date(df_customer[[2]]), \"%Y-%m\")",
        "+ ",
        "            df_customer$Tmonths <- ceiling(as.numeric(df_customer[[2]] - min(df_customer[[2]])) / 30)",
        "+ ",
        "            ",
        "+ ",
        "            #to compute \"weeks from first purchase",
        "+ ",
        "            df_customer$yr_week = paste(format(as.Date(df_customer[[2]]), \"%Y\") , \"_\" , format(as.Date(df_customer[[2]]), \"%V\"), sep =",
        "+ ",
        "                                            \"\")",
        "+ ",
        "            df_customer$Tweeks <- as.numeric(df_customer[[2]] - min(df_customer[[2]])) / 7",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #sort for output",
        "+ ",
        "            df_customer <- df_customer[order(df_customer[[2]]), ]",
        "+ ",
        "            self$data = df_customer",
        "+ ",
        "            ",
        "+ ",
        "            self$id = min(df_customer[, 1])",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$transaction_dates <- unique(df_customer[, 2])",
        "+ ",
        "            self$transaction_months <- unique(df_customer$month_yr)",
        "+ ",
        "            ",
        "+ ",
        "            self$first_purchase_date <- min(df_customer[, 2])",
        "+ ",
        "            self$last_purchase_date <- madf_customer(df_customer[, 2])",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$repeat_customer <-",
        "+ ",
        "                ifelse(length(unique(self$transaction_months)) > 1, \"Y\", \"N\")",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #construct the purchase string",
        "+ ",
        "            self$purchase_string <- NULL",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$transaction_dates = format(self$transaction_dates, \"%Y_%m\")",
        "+ ",
        "            self$purchase_count = length(unique(self$transaction_dates))  #monthly count",
        "+ ",
        "            ",
        "+ ",
        "            self$purchase_string <-",
        "+ ",
        "                create.purchase.string(df_customer, names(df_customer[1]), names(df_customer[2]))",
        "+ ",
        "            self$purchase_stringM <-",
        "+ ",
        "                create.purchase.string(df_customer, names(df_customer[1]), names(df_customer[2]), mode = \"matridf_customer\")",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$purchase_stringF <- frequency_by_T(df_customer)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$T <- ps_to_T(self$purchase_string)",
        "+ ",
        "            self$Freq <- sum(self$purchase_stringM)",
        "+ ",
        "            self$transaction_range_complete <- nchar(self$purchase_string)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$logistic_modeling_matridf_customer <-",
        "+ ",
        "                f_CustomerModelingMatridf_customer(self$T)",
        "+ ",
        "            self$transaction_string <-",
        "+ ",
        "                paste(",
        "+ ",
        "                    ifelse(self$logistic_modeling_matridf_customer[, 2] == 0, \"Y\", \"N\"),",
        "+ ",
        "                    sep = \"\",",
        "+ ",
        "                    collapse = \"\"",
        "+ ",
        "                )",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            #analysis by day",
        "+ ",
        "            self$daily$purchase_count <- length(self$transaction_dates)",
        "+ ",
        "            self$daily$frequency <- length(unique(self$transaction_dates))",
        "+ ",
        "            ",
        "+ ",
        "            #analysis by week",
        "+ ",
        "            self$weekly$Frequency <- length(unique(df_customer$yr_week))",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "            self$output <- list(c(self$global, self$monthly))",
        "+ ",
        "            self$payload <- jsonlite::toJSON(self$output)",
        "+ ",
        "            ",
        "+ ",
        "            ",
        "+ ",
        "        }",
        "+ ",
        "        ",
        "+ ",
        "        ",
        "+ ",
        "    )",
        "+ ",
        ")",
        "> ",
        "test <- Customer2$new(x)",
        "Called from: initialize(...)\n",
        "Browse[1]> ",
        "stopifnot(CADF::qc_transactional_data(df_customer) == 2)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "Browse[1]> ",
        "x",
        "  ID PURCHASE_DATE NUM_ITEMS TOTAL\n2  2    1997-01-12         1    12\n3  2    1997-01-12         5    77\n",
        "Browse[1]> ",
        "self$df_customer = x",
        "Browse[1]> ",
        "df_customer",
        "Error: object 'df_customer' not found\n",
        "Browse[1]> ",
        "self",
        "<Customer>\n  Public:\n    clone: function (deep = FALSE) \n    data: NULL\n    df_customer: data.frame\n    first_purchase_date: NULL\n    id: NULL\n    initialize: function (x) \n    last_purchase_date: NULL\n    logistic_modeling_matridf_customer: NULL\n    output: NULL\n    payload: NULL\n    purchase_count: NULL\n    repeat_customer: NULL\n    study_begin_date: NULL\n    study_name: Customer Study\n    T: NULL\n    timing: NULL\n    transaction_dates: NULL\n    transaction_range_complete: NULL\n",
        "Browse[1]> ",
        "Q",
        "\nRestarting R session...\n\n",
        "> ",
        "library(CADF)",
        "> ",
        "test <- Customer2$new(x)",
        "Called from: initialize(...)\n",
        "Browse[1]> ",
        "c",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "Customer",
        "<Customer> object generator\n  Public:\n    output: NULL\n    payload: NULL\n    df_customer: NULL\n    id: NULL\n    study_name: Customer Study\n    study_begin_date: NULL\n    timing: NULL\n    transaction_dates: NULL\n    first_purchase_date: NULL\n    last_purchase_date: NULL\n    repeat_customer: NULL\n    T: NULL\n    transaction_range_complete: NULL\n    logistic_modeling_matridf_customer: NULL\n    purchase_count: NULL\n    data: NULL\n    initialize: function (...) \n    clone: function (deep = FALSE) \n  Parent env: <environment: R_GlobalEnv>\n  Locked objects: TRUE\n  Locked class: FALSE\n  Portable: TRUE",
        "\n",
        "> ",
        "Customer$new",
        "function (...) \n{\n    inherit <- get_inherit()\n    if (!is.null(inherit)) {\n        if (!inherits(inherit, \"R6ClassGenerator\")) \n            stop(\"`inherit` must be a R6ClassGenerator.\")\n        if (!identical(portable, inherit$portable)) \n            stop(\"Sub and superclass must both be portable or non-portable.\")\n        recursive_merge <- function(obj, which) {\n            if (is.null(obj)) \n                return(NULL)\n            merge_vectors(recursive_merge(obj$get_inherit(), \n                which), obj[[which]])\n",
        "        }\n        public_fields <- merge_vectors(recursive_merge(inherit, \n            \"public_fields\"), public_fields)\n        private_fields <- merge_vectors(recursive_merge(inherit, \n            \"private_fields\"), private_fields)\n    }\n    if (class) {\n        classes <- c(classname, get_superclassnames(inherit), \n            \"R6\")\n    }\n    else {\n        classes <- NULL\n    }\n    has_priv <- has_private()\n    if (portable) {\n        if (has_priv) \n            private_bind_env <- new.env(parent = emptyenv(), \n",
        "                hash = FALSE)\n        else private_bind_env <- NULL\n        public_bind_env <- new.env(parent = emptyenv(), hash = FALSE)\n        enclos_env <- new.env(parent = parent_env, hash = FALSE)\n    }\n    else {\n        if (has_priv) {\n            private_bind_env <- new.env(parent = parent_env, \n                hash = FALSE)\n            public_bind_env <- new.env(parent = private_bind_env, \n                hash = FALSE)\n        }\n        else {\n            private_bind_env <- NULL\n            public_bind_env <- new.env(parent = parent_env, hash = FALSE)\n",
        "        }\n        enclos_env <- public_bind_env\n    }\n    enclos_env$self <- public_bind_env\n    if (has_priv) \n        enclos_env$private <- private_bind_env\n    public_methods <- assign_func_envs(public_methods, enclos_env)\n    if (has_priv) \n        private_methods <- assign_func_envs(private_methods, \n            enclos_env)\n    if (!is.null(active)) \n        active <- assign_func_envs(active, enclos_env)\n    if (length(debug_names) > 0) {\n        lapply(public_methods[names(public_methods) %in% debug_names], \n",
        "            base::debug)\n        lapply(private_methods[names(private_methods) %in% debug_names], \n            base::debug)\n        lapply(active[names(active) %in% debug_names], base::debug)\n    }\n    if (!is.null(inherit)) {\n        if (portable) {\n            super_struct <- create_super_env(inherit, public_bind_env, \n                private_bind_env, portable = TRUE, cloneable = cloneable)\n        }\n        else {\n            super_struct <- create_super_env(inherit, public_bind_env, \n                portable = FALSE, cloneable = cloneable)\n",
        "        }\n        enclos_env$super <- super_struct$bind_env\n        public_methods <- merge_vectors(super_struct$public_methods, \n            public_methods)\n        private_methods <- merge_vectors(super_struct$private_methods, \n            private_methods)\n        active <- merge_vectors(super_struct$active, active)\n    }\n    list2env2(public_methods, envir = public_bind_env)\n    list2env2(public_fields, envir = public_bind_env)\n    if (has_priv) {\n        list2env2(private_methods, envir = private_bind_env)\n",
        "        list2env2(private_fields, envir = private_bind_env)\n    }\n    if (!is.null(active)) {\n        for (name in names(active)) {\n            makeActiveBinding(name, active[[name]], public_bind_env)\n        }\n        enclos_env$.__active__ <- active\n    }\n    public_bind_env$.__enclos_env__ <- enclos_env\n    if (lock_objects) {\n        if (has_priv) \n            lockEnvironment(private_bind_env)\n        lockEnvironment(public_bind_env)\n    }\n    if (has_priv) {\n        for (name in names(private_methods)) lockBinding(name, \n",
        "            private_bind_env)\n    }\n    for (name in names(public_methods)) lockBinding(name, public_bind_env)\n    class(public_bind_env) <- classes\n    initialize <- .subset2(public_bind_env, \"initialize\")\n    if (is.function(initialize)) {\n        initialize(...)\n    }\n    else if (length(list(...)) != 0) {\n        stop(\"Called new() with arguments, but there is no initialize method.\")\n    }\n    if (is.function(.subset2(public_bind_env, \"finalize\"))) {\n        finalizer_wrapper <- function(e) {\n            .subset2(e, \"finalize\")()\n",
        "        }\n        environment(finalizer_wrapper) <- baseenv()\n        reg.finalizer(public_bind_env, finalizer_wrapper, onexit = TRUE)\n    }\n    if (has_priv) {\n        if (is.function(.subset2(private_bind_env, \"finalize\"))) {\n            finalizer_wrapper <- function(e) {\n                .subset2(e, \".__enclos_env__\")$private$finalize()\n            }\n            environment(finalizer_wrapper) <- baseenv()\n            reg.finalizer(public_bind_env, finalizer_wrapper, \n                onexit = TRUE)\n        }\n",
        "    }\n    public_bind_env\n}\n<bytecode: 0x5633246c34f8>\n<environment: 0x56332463e428>\n\nRestarting R session...\n\n",
        "> ",
        "library(CADF)",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "devtools::load_all(\".\")",
        "\u001B[38;5;232m\u001B[36mℹ\u001B[38;5;232m Loading \u001B[34mCADF\u001B[38;5;232m\u001B[39m\n",
        "Loading required package: hypergeo\n",
        "Loading required package: optimx\n",
        "Loading required package: dplyr\n",
        "\nAttaching package: ‘dplyr’\n\n",
        "The following objects are masked from ‘package:stats’:\n\n    filter, lag\n\n",
        "The following objects are masked from ‘package:base’:\n\n    intersect, setdiff, setequal, union\n\n",
        "There were 50 or more warnings (use warnings() to see the first 50)",
        "\n",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "Called from: unique(x[[1]][1])\n",
        "Browse[1]> ",
        "x",
        "Error during wrapup: ",
        "promise already under evaluation: recursive default argument reference or earlier problems?\n",
        "Error: no more error handlers available (recursive errors?); invoking 'abort' restart\n",
        "Browse[1]> ",
        "Q",
        "\nRestarting R session...\n\n",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "> ",
        "test <- Customer$new(x)",
        "Called from: eval(expr, p)\n",
        "Browse[1]> ",
        "n",
        "debug at /home/sludwig/Documents/CADF/R/qc_transactional_data.R#13: condition.1 <- length(unique(x[[1]][1]))\n",
        "Browse[2]> ",
        "x",
        "Error: object 'df_customer' not found\n",
        "Browse[2]> ",
        "ls()",
        "[1] \"x\"\n",
        "Browse[2]> ",
        "",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "In addition: ",
        "Warning message:\n",
        "In unique(x[[1]][1]) :",
        " restarting interrupted promise evaluation\n",
        "> ",
        "test <- Customer$new(x)",
        "Called from: eval(expr, p)\n",
        "Browse[1]> ",
        "n",
        "debug at /home/sludwig/Documents/CADF/R/qc_transactional_data.R#13: condition.1 <- length(unique(x[[1]][1]))\n",
        "Browse[2]> ",
        "x",
        "Error: object 'df_customer' not found\n",
        "Browse[2]> ",
        "df_customer",
        "Error: object 'df_customer' not found\n",
        "Browse[2]> ",
        "c",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "In addition: ",
        "Warning message:\n",
        "In unique(x[[1]][1]) :",
        " restarting interrupted promise evaluation\n",
        "> ",
        "test <- Customer$new(x)",
        "Called from: eval(expr, p)\n",
        "Browse[1]> ",
        "n",
        "debug at /home/sludwig/Documents/CADF/R/qc_transactional_data.R#13: condition.1 <- length(unique(x[[1]][1]))\n",
        "Browse[2]> ",
        "Q",
        "> ",
        "x",
        "  ID PURCHASE_DATE NUM_ITEMS TOTAL\n2  2    1997-01-12         1    12\n3  2    1997-01-12         5    77\n",
        "> ",
        "CADF::qc_transactional_data(x)",
        "Called from: eval(expr, p)\n",
        "Browse[1]> ",
        "n",
        "debug at /home/sludwig/Documents/CADF/R/qc_transactional_data.R#13: condition.1 <- length(unique(x[[1]][1]))\n",
        "Browse[2]> ",
        "x",
        "  ID PURCHASE_DATE NUM_ITEMS TOTAL\n2  2    1997-01-12         1    12\n3  2    1997-01-12         5    77\n",
        "Browse[2]> ",
        "c",
        "[1] 2\n",
        "> ",
        "x",
        "  ID PURCHASE_DATE NUM_ITEMS TOTAL\n2  2    1997-01-12         1    12\n3  2    1997-01-12         5    77\n",
        "> ",
        "CADF::qc_transactional_data(x)",
        "Called from: eval(expr, p)\n",
        "Browse[1]> ",
        "n",
        "debug at /home/sludwig/Documents/CADF/R/qc_transactional_data.R#13: condition.1 <- length(unique(x[[1]][1]))\n",
        "Browse[2]> ",
        "x",
        "  ID PURCHASE_DATE NUM_ITEMS TOTAL\n2  2    1997-01-12         1    12\n3  2    1997-01-12         5    77\n",
        "Browse[2]> ",
        "c",
        "[1] 2\n",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(CADF)",
        "> ",
        "test <- Customer$new(x)",
        "Error in unique(x[[1]][1]) : object 'df_customer' not found\n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(CADF)",
        "> ",
        "library(CADF)",
        "> ",
        "test <- Customer$new(x)",
        "Called from: eval(expr, p)\n",
        "Browse[1]> ",
        "n",
        "debug at /home/sludwig/Documents/CADF/R/qc_transactional_data.R#13: condition.1 <- length(unique(x[[1]][1]))\n",
        "Browse[2]> ",
        "x",
        "Error: object 'df_customer' not found\n",
        "Browse[2]> ",
        "ls",
        "function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, \n    pattern, sorted = TRUE) \n{\n    if (!missing(name)) {\n        pos <- tryCatch(name, error = function(e) e)\n        if (inherits(pos, \"error\")) {\n            name <- substitute(name)\n            if (!is.character(name)) \n                name <- deparse(name)\n            warning(gettextf(\"%s converted to character string\", \n                sQuote(name)), domain = NA)\n            pos <- name\n        }\n    }\n    all.names <- .Internal(ls(envir, all.names, sorted))\n",
        "    if (!missing(pattern)) {\n        if ((ll <- length(grep(\"[\", pattern, fixed = TRUE))) && \n            ll != length(grep(\"]\", pattern, fixed = TRUE))) {\n            if (pattern == \"[\") {\n                pattern <- \"\\\\[\"\n                warning(\"replaced regular expression pattern '[' by  '\\\\\\\\['\")\n            }\n            else if (length(grep(\"[^\\\\\\\\]\\\\[<-\", pattern))) {\n                pattern <- sub(\"\\\\[<-\", \"\\\\\\\\\\\\[<-\", pattern)\n                warning(\"replaced '[<-' by '\\\\\\\\[<-' in regular expression pattern\")\n",
        "            }\n        }\n        grep(pattern, all.names, value = TRUE)\n    }\n    else all.names\n}\n<bytecode: 0x557096b63c38>\n<environment: namespace:base>\n",
        "Browse[2]> ",
        "force(single_customer_to_CADF)",
        "function(x) {\n  return (Customer$new(x))\n}\n<bytecode: 0x5570a3ab05a0>\n<environment: namespace:CADF>\n\nRestarting R session...\n\n"
    ]
}